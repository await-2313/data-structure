#  线索二叉树

## 一、

### Q:  如何设计找线索二叉树指定节点的前驱/后继节点函数的参数呢？我现在有两种方案：
1. 直接传要找前驱的节点的地址

2. 传根节点和要找前驱的节点的val
你觉得应该是哪种方案呢？

### A:优先选择直接传要找前驱的节点的地址（指针） 作为参数，这是符合线索二叉树设计初衷、且高效的方案。    

两种方案的对比分析
**方案 1：传「目标节点的指针」（推荐）**

       		 函数原型示例：ThreadNode\* find\_predecessor(ThreadNode\* p);

 

    		核心优势：

 - **符合线索二叉树的设计初衷**：

  线索二叉树的核心价值就是「通过节点自身的指针 / 标记，无需遍历整树就能定位前驱 / 后继」，直接传目标节点指针，能完全体现这个优势（查找过程只围绕p节点及其子树 / 线索展开，无冗余操作）；

 - **效率最高**：查找前驱的时间复杂度是O(h)（h 为树高，仅找左子树最右 / 右子树最左时会遍历子树，无整树遍历），且无需额外步骤找节点；

 - **逻辑简洁**：不需要先从根节点找 “值为 val 的节点”，直接基于目标节点的ltag/lchild/rchild推导前驱，代码少、不易出错；

 - **避免值冲突**：如果树中存在重复 val 的节点，传 val 会无法确定 “到底找哪个节点的前驱”，传指针能精准定位唯一节点。

 - **适用场景**：只要你能拿到目标节点的指针（比如遍历树时缓存节点指针、或构建树时记录关键节点指针），就选这种方案 —— 这也是线索二叉树前驱 / 后继查找的标准实现方式。

 

**方案 2：传「根节点 + 目标节点的 val」（不推荐）**

        	函数原型示例：ThreadNode* find_predecessor(ThreadTree root, int val);



    		核心问题：

- **违背线索二叉树的设计初衷**：为了找前驱，你需要先从根节点遍历整树找到 “val 对应的节点”（这一步已经遍历了整树 / 部分树），再基于该节点找前驱 —— 完全失去了 “无需遍历整树找前驱” 的核心要求；

- **效率低且冗余**：多了 “找节点” 的步骤，时间复杂度至少是O(n)（n 为节点数），抵消了线索二叉树的优势；

- **存在值冲突风险**：若树中有多个节点 val 相同，无法确定目标节点，只能返回第一个匹配的节点，逻辑不严谨；

- **参数冗余**：找前驱的核心逻辑和根节点无关（仅和目标节点的ltag/ 指针有关），传根节点只是为了 “先找节点”，属于额外负担。

- **仅有的适用场景**：只有一种情况可考虑 —— 你完全拿不到目标节点的指针，只能通过 val 定位（比如用户只输入 val，无节点指针缓存），但这是 “无奈之选”，而非最优解。

## 二、

### **错误代码**：
```
void preOrderThreadingRecursive(ThreadTree root,ThreadNode** pre)

{

//先序线索化二叉树

if(!root) return;



if(*pre && (*pre)->rchild == NULL)

{

     (*pre)->rchild = root;

     (*pre)->rtag  =1;

}

if(!root->lchild)

{

     root->lchild = *pre;

     root->ltag = 1;

}

*pre = root;

preOrderThreadingRecursive(root->lchild,pre);

preOrderThreadingRecursive(root->rchild,pre);

}
```
### **正确代码**：
```c

if(root->ltag == 0)preOrderThreadingRecursive(root->lchild,pre);
if(root->rtag == 0)preOrderThreadingRecursive(root->rchild,pre);
```
### Q:
- 为什么前序遍历需要判断是否是孩子，同样的代码，中序遍历就不用判断?
- 为什么要先处理当前节点的前驱，再处理前驱的后继，而不是先处理前驱的后继，再处理当前节点的前驱?
### A:
- 不是中序 “不用判断”，而是中序的标准递归顺序（先递归左，再处理线索）避开了线索指针的访问；前序的标准递归顺序（先处理线索，再递归）必须判断，否则会访问线索指针。
- 1. 逻辑上：前驱是后继的前提，保证线索双向一致；
  2. 风险上：避免提前覆盖前驱的真孩子；
  3. 时间线上：符合 “前驱→当前→后继” 的遍历顺序。
