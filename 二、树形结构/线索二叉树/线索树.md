# &nbsp;线索二叉树

Q:  如何设计找线索二叉树指定节点的前驱/后继节点函数的参数呢？我现在有两种方案，一种是直接传要找前驱的节点的地址，另一种是传根节点和要找前驱的节点的val，你觉得应该是哪种方案呢？

&nbsp;   A:优先选择直接传要找前驱的节点的地址（指针） 作为参数，这是符合线索二叉树设计初衷、且高效的方案。



两种方案的对比分析

&nbsp;   方案 1：传「目标节点的指针」（推荐）

&nbsp;       函数原型示例：ThreadNode\* find\_predecessor(ThreadNode\* p);

&nbsp;   

&nbsp;   核心优势：

&nbsp;       1.符合线索二叉树的设计初衷：

&nbsp;           线索二叉树的核心价值就是「通过节点自身的指针 / 标记，无需遍历整树就能定位前驱 / 后继」，直接传目标节点指针，

&nbsp;       能完全体现这个优势（查找过程只围绕p节点及其子树 / 线索展开，无冗余操作）；

&nbsp;       

&nbsp;       2.效率最高：查找前驱的时间复杂度是O(h)（h 为树高，仅找左子树最右 / 右子树最左时会遍历子树，无整树遍历），且无需额外步骤找节点；

&nbsp;       3.逻辑简洁：不需要先从根节点找 “值为 val 的节点”，直接基于目标节点的ltag/lchild/rchild推导前驱，代码少、不易出错；

&nbsp;       4.避免值冲突：如果树中存在重复 val 的节点，传 val 会无法确定 “到底找哪个节点的前驱”，传指针能精准定位唯一节点。

&nbsp;       5.适用场景：只要你能拿到目标节点的指针（比如遍历树时缓存节点指针、或构建树时记录关键节点指针），就选这种方案 —— 这也是线索二叉树前驱 / 后继查找的标准实现方式。

&nbsp;   

&nbsp;   方案 2：传「根节点 + 目标节点的 val」（不推荐）

&nbsp;       函数原型示例：ThreadNode\* find\_predecessor(ThreadTree root, int val);



&nbsp;   核心问题：

&nbsp;       1、违背线索二叉树的设计初衷：为了找前驱，你需要先从根节点遍历整树找到 “val 对应的节点”（这一步已经遍历了整树 / 部分树），

&nbsp;       再基于该节点找前驱 —— 完全失去了 “无需遍历整树找前驱” 的核心要求；

&nbsp;       

&nbsp;       2.效率低且冗余：多了 “找节点” 的步骤，时间复杂度至少是O(n)（n 为节点数），抵消了线索二叉树的优势；

&nbsp;       3.存在值冲突风险：若树中有多个节点 val 相同，无法确定目标节点，只能返回第一个匹配的节点，逻辑不严谨；

&nbsp;       4.参数冗余：找前驱的核心逻辑和根节点无关（仅和目标节点的ltag/ 指针有关），传根节点只是为了 “先找节点”，属于额外负担。

&nbsp;       5.仅有的适用场景：只有一种情况可考虑 —— 你完全拿不到目标节点的指针，只能通过 val 定位（比如用户只输入 val，无节点指针缓存），但这是 “无奈之选”，而非最优解。

