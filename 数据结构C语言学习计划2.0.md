# 数据结构C语言手写代码学习计划（完整版，12周）
## 核心原则
1.  手写优先：先闭卷手写代码，再对照修正，最后编译运行验证，拒绝“眼会手不会”；
2.  从易到难：线性结构 → 树形结构 → 串/哈希/排序 → 图 → 平衡树 → 综合巩固，循序渐进降低学习门槛；
3.  每日验收：完成任务后必须手写代码并编译运行通过，才算当日达标，不赶进度重质量；
4.  理解为本：不死记代码，重点掌握“为什么这么实现”（如线索化目的、KMP减少回溯、图算法贪心思想）；
5.  错题复盘：每模块结束后整理手写错误，标注原因并修正，形成专属错题本，避免重复踩坑。

## 详细周计划
### 第1周：线性结构核心实现（单链表+栈+队列）
| 日期 | 核心任务 | 具体内容 | 验收标准 |
|------|----------|----------|----------|
| Day1 | 单链表基础 | 手写：结构体定义+创建节点+头插/尾插建表+遍历 | 能独立写出尾插法建表，遍历输出正确，无语法错误 |
| Day2 | 单链表进阶 | 手写：删除指定节点+反转链表+销毁链表+查找指定节点 | 反转链表无bug，销毁后无野指针，查找结果准确 |
| Day3 | 链式栈 | 手写：栈结构体+初始化+入栈+出栈+判空+销毁+获取栈顶元素 | 入栈3个元素、出栈2个后，栈顶元素获取正确，栈大小统计无误 |
| Day4 | 循环队列 | 手写：队列结构体+初始化+判空/满+入队+出队+获取队头元素 | 能解释“判满留空位”的原因，入队/出队循环指针正确，无数组越界 |
| Day5 | 线性结构复习 | 闭卷手写单链表/栈/队列所有核心代码 | 代码无语法错误，一次性手写完成率≥80%，编译运行通过 |
| Day6 | 线性结构错题修正 | 整理手写错误（如链表反转漏next、队列判满错误），重新实现 | 错误点标注原因（如“队列判满未取模”），修正后代码运行正确 |
| Day7 | 线性结构综合练习 | 手写“链表版队列”（用单链表实现队列的入队/出队/判空） | 综合代码能正确运行，理解链表和队列的结合逻辑 |

### 第2周：二叉树基础操作
| 日期 | 核心任务 | 具体内容 | 验收标准 |
|------|----------|----------|----------|
| Day1 | 二叉树创建 | 手写：结构体定义+先序创建二叉树（-1表空节点） | 能按给定先序序列创建二叉树，无内存泄漏 |
| Day2 | 二叉树递归遍历 | 手写：前序+中序+后序遍历 | 三种遍历输出符合预期，理解“根左右/左根右/左右根”的顺序 |
| Day3 | 二叉树层序遍历 | 手写：数组模拟队列实现层序遍历+统计叶子节点数 | 层序遍历输出按层排列，队列操作无越界，叶子节点数统计正确 |
| Day4 | 二叉树工具函数 | 手写：求树高+销毁二叉树+统计总节点数 | 能解释“后序销毁”的原因，树高、总节点数计算正确 |
| Day5 | 二叉树非递归遍历 | 手写：栈模拟实现前序/中序非递归遍历 | 非递归遍历输出和递归版一致，理解栈模拟递归的逻辑 |
| Day6 | 二叉树错题修正 | 整理层序遍历队列操作、非递归遍历栈操作的错误，重新实现 | 错误点标注原因，修正后代码运行正确 |
| Day7 | 二叉树进阶练习 | 手写：二叉树后序非递归遍历+判断两棵二叉树是否相同 | 后序非递归遍历输出正确，二叉树判同逻辑无误 |

### 第3周：二叉排序树（BST）核心实现
| 日期 | 核心任务 | 具体内容 | 验收标准 |
|------|----------|----------|----------|
| Day1 | BST插入 | 手写：结构体定义+创建节点+插入（二级指针） | 能解释“二级指针”的作用，插入后根节点指向正确 |
| Day2 | BST查找+遍历 | 手写：查找节点+中序遍历+找前驱/后继节点 | 查找存在/不存在的节点返回正确，中序遍历为升序，前驱/后继查找无误 |
| Day3 | BST删除（简单场景） | 手写：删除叶子节点+删除只有单孩子的节点 | 删除后中序遍历仍为升序，节点内存释放正确 |
| Day4 | BST删除（复杂场景） | 手写：删除有双孩子的节点（找右子树最小节点/左子树最大节点） | 能解释“找后继/前驱节点”的原因，删除后树结构正确 |
| Day5 | BST复习 | 闭卷手写BST插入/查找/删除/遍历所有代码 | 代码无语法错误，编译运行通过 |
| Day6 | BST错题修正 | 整理删除双孩子节点、二级指针传参的错误，重新实现 | 错误点标注原因，修正后代码运行正确 |
| Day7 | BST综合练习 | 手写：从有序数组构建平衡BST+BST转有序双向链表 | 平衡BST构建后树高接近logn，双向链表转换后遍历正确 |

### 第4周：二叉树线索化
| 日期 | 核心任务 | 具体内容 | 验收标准 |
|------|----------|----------|----------|
| Day1 | 线索二叉树基础 | 学习线索化概念，手写：线索二叉树节点结构体（增加ltag/rtag、前驱/后继指针） | 能解释ltag/rtag含义（0-孩子，1-线索），结构体定义正确 |
| Day2 | 中序线索化二叉树 | 手写：中序线索化递归函数+初始化线索二叉树 | 线索化后，空指针正确指向前驱/后继，无内存泄漏 |
| Day3 | 中序线索二叉树遍历 | 手写：利用线索实现中序遍历（无需栈） | 遍历输出和普通中序一致，理解“线索替代栈”的核心逻辑 |
| Day4 | 线索二叉树反向查找 | 手写：找线索二叉树指定节点的前驱/后继节点 | 前驱/后继查找正确，无需遍历整棵树 |
| Day5 | 线索二叉树复习 | 闭卷手写线索化+线索遍历核心代码 | 代码无语法错误，编译运行通过 |
| Day6 | 线索二叉树错题修正 | 整理线索化时指针赋值错误、遍历边界错误，重新实现 | 错误点标注原因，修正后代码运行正确 |
| Day7 | 线索二叉树综合练习 | 手写：先序线索化二叉树+先序线索遍历 | 先序线索化逻辑正确，遍历输出符合预期 |

### 第5周：串（字符串）操作
| 日期 | 核心任务 | 具体内容 | 验收标准 |
|------|----------|----------|----------|
| Day1 | 串的定长数组实现 | 手写：串结构体定义+初始化+赋值+拼接+求长度 | 串拼接后长度计算正确，赋值无数组越界 |
| Day2 | 串的基本操作 | 手写：串比较+求子串+定位子串（BF算法） | BF算法能正确找到子串首次出现位置，子串截取无越界 |
| Day3 | 串的模式匹配（KMP算法） | 手写：求next数组+KMP核心匹配函数 | KMP算法匹配结果和BF一致，能解释next数组的作用（减少回溯） |
| Day4 | 串的链式存储实现 | 手写：链式串结构体+初始化+遍历+拼接 | 链式串拼接后遍历正确，理解定长数组vs链式存储的优缺点 |
| Day5 | 串操作复习 | 闭卷手写定长串/KMP/链式串核心代码 | 代码无语法错误，编译运行通过 |
| Day6 | 串操作错题修正 | 整理KMP next数组计算错误、子串截取越界的错误，重新实现 | 错误点标注原因，修正后代码运行正确 |
| Day7 | 串综合练习 | 手写：KMP算法实现字符串替换+判断字符串是否为回文 | 字符串替换逻辑正确，回文判断无误 |

### 第6周：哈希表（完整实现）
| 日期 | 核心任务 | 具体内容 | 验收标准 |
|------|----------|----------|----------|
| Day1 | 哈希表基础 | 手写：拉链法哈希表结构体+哈希函数（取模/除留余数）+初始化 | 能解释哈希函数设计原则，初始化后哈希表数组全为NULL |
| Day2 | 哈希表插入+查找 | 手写：拉链法插入键值对（处理哈希冲突）+按key查找value | 插入冲突键（如key=1和key=11）后，查找仍能返回正确value |
| Day3 | 哈希表删除+修改 | 手写：删除指定key节点+修改指定key的value值 | 删除后查找该key返回-1，修改后value更新正确，无内存泄漏 |
| Day4 | 哈希表拓展（开放定址法） | 手写：线性探测法实现哈希表插入/查找/删除 | 理解开放定址法vs拉链法的差异，线性探测无聚集错误 |
| Day5 | 哈希表复习 | 闭卷手写拉链法/开放定址法所有核心代码 | 代码无语法错误，编译运行通过 |
| Day6 | 哈希表错题修正 | 整理哈希冲突处理、删除指针调整的错误，重新实现 | 错误点标注原因，修正后代码运行正确 |
| Day7 | 哈希表综合练习 | 手写：哈希表统计文本中单词出现次数+哈希表实现两数之和（LeetCode 1） | 统计结果正确，两数之和查找效率接近O(1) |

### 第7周：经典排序算法（完整版）
| 日期 | 核心任务 | 具体内容 | 验收标准 |
|------|----------|----------|----------|
| Day1 | 快速排序+优化 | 手写：分区函数+快速排序递归函数+基准值优化（三数取中） | 排序数组{8,5,7,9,2,4,1,6}结果升序，基准值优化后减少最坏情况发生 |
| Day2 | 归并排序+非递归版 | 手写：合并函数+归并排序递归/非递归函数 | 排序结果正确，能解释“分治+合并”的核心思想，非递归版无数组越界 |
| Day3 | 堆排序 | 手写：堆调整函数（大顶堆/小顶堆）+堆排序主函数+堆初始化 | 排序结果正确，能解释“大顶堆构建→堆顶交换→堆调整”的完整流程 |
| Day4 | 插入/冒泡/选择排序 | 手写：直接插入排序+冒泡排序（优化版）+简单选择排序 | 三种排序结果正确，能区分时间复杂度（O(n²)）和稳定性 |
| Day5 | 排序算法对比实现 | 手写：快排/归并/堆排/插入排序对比代码（同一数组测试） | 四种排序结果一致，能打印时间复杂度相关日志验证效率 |
| Day6 | 排序算法错题修正 | 整理快排分区边界、归并合并漏拷贝、堆调整边界的错误，重新实现 | 错误点标注原因，修正后代码运行正确 |
| Day7 | 排序算法综合练习 | 手写：①快排实现数组去重 ②归并实现topK ③堆排序实现中位数查找 | 三个综合功能结果正确，理解排序算法的实际业务场景应用 |

### 第8周：图的存储与遍历
| 日期 | 核心任务 | 具体内容 | 验收标准 |
|------|----------|----------|----------|
| Day1 | 图的邻接矩阵存储 | 手写：邻接矩阵结构体+初始化+创建无向/有向图 | 邻接矩阵能正确表示图的边关系，无向图矩阵对称 |
| Day2 | 图的邻接表存储 | 手写：邻接表结构体+初始化+创建无向/有向图+销毁邻接表 | 邻接表能正确表示边关系，销毁后无内存泄漏 |
| Day3 | 图的深度优先遍历（DFS） | 手写：邻接表实现DFS（递归+非递归） | DFS遍历顺序符合预期，能标记访问节点避免环遍历 |
| Day4 | 图的广度优先遍历（BFS） | 手写：邻接表实现BFS（队列模拟） | BFS遍历按层输出，队列操作无越界，访问标记正确 |
| Day5 | 图的遍历复习 | 闭卷手写邻接矩阵/邻接表的DFS/BFS代码 | 代码无语法错误，编译运行通过 |
| Day6 | 图的遍历错题修正 | 整理遍历未标记访问、邻接表节点创建错误，重新实现 | 错误点标注原因，修正后代码运行正确 |
| Day7 | 图的遍历综合练习 | 手写：判断图是否有环（DFS/BFS）+ 统计连通分量数 | 环判断、连通分量统计结果正确 |

### 第9周：图的高级应用（最短路径+最小生成树）
| 日期 | 核心任务 | 具体内容 | 验收标准 |
|------|----------|----------|----------|
| Day1 | 迪杰斯特拉（Dijkstra）算法 | 手写：邻接矩阵实现Dijkstra（单源最短路径，无权/有权图） | 能正确计算指定源点到所有节点的最短路径，理解贪心思想 |
| Day2 | 弗洛伊德（Floyd）算法 | 手写：邻接矩阵实现Floyd（多源最短路径） | 能正确计算任意两点间最短路径，理解动态规划思想 |
| Day3 | 最小生成树 - Prim算法 | 手写：邻接矩阵实现Prim算法（从顶点出发构建MST） | MST权值和最小，能解释“选最近顶点”的贪心逻辑 |
| Day4 | 最小生成树 - Kruskal算法 | 手写：邻接表+并查集实现Kruskal算法（从边出发构建MST） | 能解释并查集的作用（判断环），MST构建正确 |
| Day5 | 图的高级算法复习 | 闭卷手写Dijkstra/Floyd/Prim/Kruskal核心代码 | 代码无语法错误，编译运行通过 |
| Day6 | 图算法错题修正 | 整理最短路径权值计算、并查集路径压缩错误，重新实现 | 错误点标注原因，修正后代码运行正确 |
| Day7 | 图算法综合练习 | 手写：Dijkstra实现带权图最短路径规划+Kruskal实现校园网布线（最小成本） | 综合场景结果正确，理解图算法的工程应用 |

### 第10周：图的进阶应用（关键路径+拓扑排序）
| 日期 | 核心任务 | 具体内容 | 验收标准 |
|------|----------|----------|----------|
| Day1 | 拓扑排序 | 手写：邻接表+入度表实现拓扑排序（Kahn算法） | 能正确输出有向无环图（DAG）的拓扑序列，判断图是否有环 |
| Day2 | AOE网与关键路径基础 | 学习AOE网概念，手写：AOE网邻接表结构体（增加边权/事件时间属性） | 能区分AOE网和普通有向图，结构体定义正确 |
| Day3 | 关键路径 - 最早/最迟发生时间 | 手写：计算事件的最早发生时间（ve）+ 最迟发生时间（vl） | ve/vl计算正确，理解“拓扑序算ve，逆拓扑序算vl”的逻辑 |
| Day4 | 关键路径 - 活动时间计算 | 手写：计算活动的最早开始时间（e）+ 最迟开始时间（l）+ 识别关键活动 | 能正确筛选出关键活动，理解“l-e=0为关键活动” |
| Day5 | 关键路径完整实现 | 手写：AOE网构建+拓扑排序+ve/vl/e/l计算+输出关键路径 | 关键路径输出正确，权值和等于工程最短完成时间 |
| Day6 | 关键路径错题修正 | 整理时间计算边界、拓扑序逆序错误，重新实现 | 错误点标注原因，修正后代码运行正确 |
| Day7 | 图终极综合练习 | 手写：完整AOE网关键路径分析+拓扑排序验证+环检测 | 全流程代码无bug，能解释关键路径的工程意义（如项目工期优化） |

### 第11周：红黑树+AVL树（平衡二叉树进阶）
| 日期 | 核心任务 | 具体内容 | 验收标准 |
|------|----------|----------|----------|
| Day1 | AVL树基础 | 学习AVL树平衡因子，手写：AVL节点结构体（增加平衡因子）+ 求平衡因子 | 能解释平衡因子定义（右高-左高），平衡因子计算正确 |
| Day2 | AVL树旋转操作 | 手写：左旋+右旋+四种失衡调整（LL/LR/RL/RR） | 旋转后平衡因子恢复为-1/0/1，仍满足BST特性 |
| Day3 | AVL树插入+平衡调整 | 手写：AVL树插入节点+插入后平衡调整 | 插入后树的平衡因子符合要求，无失衡节点 |
| Day4 | 红黑树基础 | 学习红黑树5大特性，手写：红黑树节点结构体（增加颜色属性） | 能口述5个特性，区分红黑树与AVL树的平衡差异 |
| Day5 | 红黑树旋转+插入修复 | 手写：红黑树左旋/右旋+插入节点+插入后颜色修复（改色/旋转） | 插入后满足红黑树5大特性，理解“红色节点减少冲突”的设计 |
| Day6 | 平衡树错题修正 | 整理AVL平衡因子计算、红黑树颜色修复错误，重新实现 | 错误点标注原因，修正后代码运行正确 |
| Day7 | 平衡树综合对比 | 手写：AVL/红黑树/BST插入相同数据，对比树高+查找效率 | 能解释红黑树“近似平衡”的优势，理解不同平衡树的适用场景 |

### 第12周：全模块综合巩固+算法刷题
| 日期 | 核心任务 | 具体内容 | 验收标准 |
|------|----------|----------|----------|
| Day1-3 | 全模块代码复盘 | 闭卷手写核心模块代码：<br>1. 单链表/栈/队列 <br>2. BST/线索二叉树 <br>3. 哈希表/排序 <br>4. 图的遍历/最短路径/关键路径 | 80%以上代码一次性手写正确，编译运行通过 |
| Day4-5 | 算法题刷题（LeetCode/牛客） | 刷中等难度题：<br>1. 链表：环形链表（142）、K个一组反转（25）<br>2. 树：二叉树的层序遍历II（107）、验证BST（98）<br>3. 图：岛屿数量（200）、课程表（207） | 每题先手写代码再提交，通过率≥70%，能解释解题思路 |
| Day6 | 模拟面试+易错点梳理 | 口述核心代码逻辑（如BST删除、Dijkstra、关键路径），整理全模块易错点 | 能清晰口述代码逻辑，标注所有高频错误（如内存泄漏、边界条件、指针操作） |
| Day7 | 学习总结+后续规划 | 整理各模块核心知识点思维导图，制定进阶方向（如C++封装、算法竞赛、工程应用） | 思维导图覆盖所有数据结构核心，后续规划贴合自身学习目标 |

## 额外执行建议
1.  工具要求：
    - 编译时开启GCC警告（`gcc -Wall 文件名.c -o 可执行文件`），及时发现内存泄漏、野指针；
    - 使用`valgrind`（Linux/Mac）或Visual Leak Detector（Windows）检测内存泄漏；
    - 用VSCode+插件（如C/C++、DrawIO）整理思维导图和错题本。
2.  节奏调整：
    - 若图/红黑树等模块难度大，可单模块延长1-2天，保证理解透彻，不赶进度；
    - 每日学习时间建议2-3小时，优先保证“手写+编译运行”，而非单纯看代码。
3.  错题管理：
    - 按模块建立错题文档，格式为“错误代码 + 错误原因 + 修正方案 + 注意事项”；
    - 每周复盘错题，避免重复踩坑。
4.  进阶方向：
    - 完成12周计划后，可学习C++封装数据结构（如用类实现BST、图）；
    - 刷算法竞赛题（如蓝桥杯、ACM入门题），强化数据结构应用能力；
    - 学习数据库索引、Redis底层等工程化场景，理解数据结构的实际落地。